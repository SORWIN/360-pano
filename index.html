<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>360 Панорама — офлайн</title>
<link rel="icon" href="data:,">
<style>
  html,body{margin:0;height:100%;background:#000;color:#ddd;font-family:system-ui}
  #ui{position:fixed;left:12px;top:12px;display:flex;gap:8px;z-index:10;flex-wrap:wrap}
  #ui>*{background:#111a;border:1px solid #333;border-radius:10px;padding:6px 10px;font-size:14px}
  #note{position:fixed;left:12px;bottom:12px;background:#111a;border:1px solid #333;border-radius:10px;padding:8px 10px;z-index:10;max-width:min(92vw,860px)}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;cursor:grab}
  canvas.dragging{cursor:grabbing}
  button{cursor:pointer}
</style>
</head>
<body>
<div id="ui">
  <input id="picker" type="file" accept="image/jpeg,image/png,image/webp">
  <button id="gyroBtn">Гироскоп: выкл</button>
  <button id="centerBtn">Центр</button>
  <button id="fsBtn">Fullscreen</button>
</div>
<div id="note">Ищу <code>panorama_4096x2048.jpg</code> рядом с этим файлом… ЛКМ/тач — вращение, колесо/пинч — зум.</div>
<canvas id="gl"></canvas>

<script>
(() => {
  const cnv = document.getElementById('gl');
  const gl = cnv.getContext('webgl', { antialias:false, alpha:false });
  const note = document.getElementById('note');
  const say = s => note.textContent = s;
  if (!gl) { say('WebGL недоступен.'); return; }

  // --- Шейдеры (yaw, pitch, roll)
  const vsSrc = `
    attribute vec2 p;
    varying vec2 v;
    void main(){ v=p; gl_Position=vec4(p,0.0,1.0); }
  `;
  const fsSrc = `
    precision highp float;
    varying vec2 v;
    uniform sampler2D pano;
    uniform vec2 res;
    uniform float yaw;
    uniform float pitch;
    uniform float roll;
    uniform float fov;

    vec3 rayDir(vec2 uv, float fovY){
      float yScale = tan(fovY*0.5);
      float xScale = yScale * (res.x/res.y);
      return normalize(vec3(uv.x*xScale, uv.y*yScale, -1.0));
    }
    mat3 rotX(float a){ float c=cos(a), s=sin(a); return mat3(1.,0.,0., 0.,c,s, 0.,-s,c); }
    mat3 rotY(float a){ float c=cos(a), s=sin(a); return mat3(c,0.,-s, 0.,1.,0., s,0.,c); }
    mat3 rotZ(float a){ float c=cos(a), s=sin(a); return mat3(c,s,0., -s,c,0., 0.,0.,1.); }

    void main(){
      vec3 d = rotZ(roll) * rotY(yaw) * (rotX(pitch) * rayDir(v, fov));
      float lon = atan(d.z, d.x);
      float lat = asin(clamp(d.y, -1.0, 1.0));
      float u = lon/(2.0*3.141592653589793) + 0.5;
      float vv = 0.5 - (lat/3.141592653589793);
      u = fract(u);
      vv = clamp(vv, 0.0, 1.0);
      gl_FragColor = texture2D(pano, vec2(u, vv));
    }
  `;
  function sh(t,src){const s=gl.createShader(t);gl.shaderSource(s,src);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))throw new Error(gl.getShaderInfoLog(s));return s;}
  const prog = gl.createProgram();
  gl.attachShader(prog, sh(gl.VERTEX_SHADER, vsSrc));
  gl.attachShader(prog, sh(gl.FRAGMENT_SHADER, fsSrc));
  gl.linkProgram(prog);
  gl.useProgram(prog);

  // --- Геометрия
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1, 1,-1,1,1,-1,1]), gl.STATIC_DRAW);
  const locP = gl.getAttribLocation(prog, 'p');
  gl.enableVertexAttribArray(locP);
  gl.vertexAttribPointer(locP, 2, gl.FLOAT, false, 0, 0);

  // --- Uniforms
  const uRes   = gl.getUniformLocation(prog, 'res');
  const uYaw   = gl.getUniformLocation(prog, 'yaw');
  const uPitch = gl.getUniformLocation(prog, 'pitch');
  const uRoll  = gl.getUniformLocation(prog, 'roll');
  const uFov   = gl.getUniformLocation(prog, 'fov');

  // --- Текстура
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  function loadImage(src){ return new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=src; }); }
  function setTexture(img){ gl.bindTexture(gl.TEXTURE_2D, tex); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img); }

  loadImage('panorama_4096x2048.jpg')
    .then(img=>{ setTexture(img); say('Загружено: panorama_4096x2048.jpg'); })
    .catch(()=> say('Выбери файл панорамы.'));

  document.getElementById('picker').addEventListener('change', e=>{
    const f=e.target.files&&e.target.files[0]; if(!f) return;
    loadImage(URL.createObjectURL(f)).then(img=>{ setTexture(img); say('Загружено: '+f.name); });
  });

  // --- Состояние
  let yaw=0,pitch=0,roll=0,fov=Math.PI/3;
  const PITCH_LIMIT = Math.PI/2 - 0.001;
  let gyroOn=false, orientHandler=null, prevA=null, yawVel=0;
  const LPF=0.25, HORIZ_SOFT=0.3;
  const gyroBtn=document.getElementById('gyroBtn');

  // ориентация экрана для корректного roll в портрете/ландшафте
  let scrAng = (screen.orientation && screen.orientation.angle) || window.orientation || 0;
  window.addEventListener('orientationchange', ()=> {
    scrAng = (screen.orientation && screen.orientation.angle) || window.orientation || 0;
  });

  function handleOrient(ev){
    const a=(ev.alpha||0)*Math.PI/180;   // yaw
    const b=(ev.beta ||0)*Math.PI/180;   // pitch-сенсор
    const g=(ev.gamma||0)*Math.PI/180;   // roll-сенсор

    // unwrap + сглаживание yaw
    if(prevA===null) prevA=a;
    let d=a-prevA; while(d>Math.PI)d-=2*Math.PI; while(d<-Math.PI)d+=2*Math.PI;
    const aSmooth=prevA+d;
    let da=aSmooth-prevA; prevA=aSmooth;
    const w=Math.max(0,Math.min(1,Math.abs(Math.cos(b))-HORIZ_SOFT))/(1-HORIZ_SOFT);
    da*=w;
    yawVel=yawVel*(1-LPF)+da*LPF;
    yaw+=yawVel;

    // ПОЛНЫЙ НАКЛОН ВПЕРЕД/НАЗАД: возвращаем pitch из β
    pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, b - Math.PI/2));

    // НАКЛОН ВЛЕВО/ВПРАВО: roll из γ с учётом ориентации экрана
    const ang = ((scrAng%360)+360)%360;
    let r = -g;           // портрет: телефон влево → картинка вправо
    if (ang===90)  r = -b;  // ландшафт-право
    if (ang===180) r =  g;  // перевёрнутый портрет
    if (ang===270) r =  b;  // ландшафт-лево
    roll = r;
  }

  async function enableGyro(){
    if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
      try{const s=await DeviceMotionEvent.requestPermission(); if(s!=='granted'){say('Разреши доступ к датчикам.');return;}}catch{return;}
    }
    orientHandler=handleOrient;
    window.addEventListener('deviceorientation',orientHandler,true);
    gyroOn=true;
    gyroBtn.textContent='Гироскоп: вкл';
  }

  function disableGyro(){
    if(orientHandler) window.removeEventListener('deviceorientation',orientHandler,true);
    orientHandler=null; gyroOn=false;
    gyroBtn.textContent='Гироскоп: выкл';
  }

  gyroBtn.addEventListener('click',()=> gyroOn ? disableGyro():enableGyro());
  enableGyro(); // автозапуск

  // --- Pointer controls
  let drag=false, lastX=0, lastY=0;
  const DRAG_SPEED = 0.0025;

  function endDrag(e){
    if(!drag) return;
    drag=false;
    cnv.classList.remove('dragging');
    try{ cnv.releasePointerCapture(e.pointerId); }catch(_){}
  }

  cnv.addEventListener('pointerdown', e=>{
    if(e.button!==undefined && e.button!==0) return;
    drag=true;
    lastX=e.clientX;
    lastY=e.clientY;
    cnv.classList.add('dragging');
    cnv.setPointerCapture(e.pointerId);
  });

  cnv.addEventListener('pointermove', e=>{
    if(!drag) return;
    const dx=e.clientX-lastX;
    const dy=e.clientY-lastY;
    lastX=e.clientX;
    lastY=e.clientY;
    yaw+=dx*DRAG_SPEED;
    pitch=Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch+dy*DRAG_SPEED));
  });

  cnv.addEventListener('pointerup', endDrag);
  cnv.addEventListener('pointercancel', endDrag);
  cnv.addEventListener('lostpointercapture', ()=>{
    drag=false;
    cnv.classList.remove('dragging');
  });

  // --- Resize + Render
  function resize(){
    const ratio=Math.min(window.devicePixelRatio||1,1.5);
    cnv.width=innerWidth*ratio; cnv.height=innerHeight*ratio;
    gl.viewport(0,0,cnv.width,cnv.height);
    gl.uniform2f(uRes,cnv.width,cnv.height);
  }
  addEventListener('resize',resize); resize();

  function frame(){
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(prog);
    gl.bindTexture(gl.TEXTURE_2D,tex);
    gl.uniform1f(uYaw,yaw);
    gl.uniform1f(uPitch,pitch);
    gl.uniform1f(uRoll,roll);
    gl.uniform1f(uFov,fov);
    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(frame);
  }
  frame();
})();
</script>
</body>
</html>
