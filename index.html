<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>360 Панорама — офлайн</title>
<link rel="icon" href="data:,">
<style>
  html,body{margin:0;height:100%;background:#000;color:#ddd;font-family:system-ui}
  #ui{position:fixed;left:12px;top:12px;display:flex;gap:8px;z-index:10;flex-wrap:wrap}
  #ui>*{background:#111a;border:1px solid #333;border-radius:10px;padding:6px 10px;font-size:14px}
  #note{position:fixed;left:12px;bottom:12px;background:#111a;border:1px solid #333;border-radius:10px;padding:8px 10px;z-index:10;max-width:min(92vw,860px)}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;cursor:grab}
  canvas.dragging{cursor:grabbing}
  button{cursor:pointer}
</style>
</head>
<body>
<div id="ui">
  <input id="picker" type="file" accept="image/jpeg,image/png,image/webp">
  <button id="gyroBtn">Гироскоп: выкл</button>
  <button id="centerBtn">Центр</button>
  <button id="fsBtn">Fullscreen</button>
</div>
<div id="note">Ищу <code>panorama_4096x2048.jpg</code> рядом с этим файлом… ЛКМ/тач — вращение, колесо/пинч — зум.</div>
<canvas id="gl"></canvas>

<script>
(() => {
  const cnv = document.getElementById('gl');
  const gl = cnv.getContext('webgl', { antialias:false, alpha:false });
  const note = document.getElementById('note');
  const say = s => note.textContent = s;
  if (!gl) { say('WebGL недоступен.'); return; }

  // --- Шейдеры (yaw, pitch, roll)
  const vsSrc = `
    attribute vec2 p;
    varying vec2 v;
    void main(){ v=p; gl_Position=vec4(p,0.0,1.0); }
  `;
  const fsSrc = `
    precision highp float;
    varying vec2 v;
    uniform sampler2D pano;
    uniform vec2 res;
    uniform float yaw;
    uniform float pitch;
    uniform float roll;
    uniform float fov;

    vec3 rayDir(vec2 uv, float fovY){
      float yScale = tan(fovY*0.5);
      float xScale = yScale * (res.x/res.y);
      return normalize(vec3(uv.x*xScale, uv.y*yScale, -1.0));
    }
    mat3 rotX(float a){ float c=cos(a), s=sin(a); return mat3(1.,0.,0., 0.,c,s, 0.,-s,c); }
    mat3 rotY(float a){ float c=cos(a), s=sin(a); return mat3(c,0.,-s, 0.,1.,0., s,0.,c); }
    mat3 rotZ(float a){ float c=cos(a), s=sin(a); return mat3(c,s,0., -s,c,0., 0.,0.,1.); }

    void main(){
      vec3 d = rotZ(roll) * rotY(yaw) * (rotX(pitch) * rayDir(v, fov));
      float lon = atan(d.z, d.x);
      float lat = asin(clamp(d.y, -1.0, 1.0));
      float u = lon/(2.0*3.141592653589793) + 0.5;
      float vv = 0.5 - (lat/3.141592653589793);
      u = fract(u);
      vv = clamp(vv, 0.0, 1.0);
      gl_FragColor = texture2D(pano, vec2(u, vv));
    }
  `;
  function sh(t,src){const s=gl.createShader(t);gl.shaderSource(s,src);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))throw new Error(gl.getShaderInfoLog(s));return s;}
  const prog = gl.createProgram();
  gl.attachShader(prog, sh(gl.VERTEX_SHADER, vsSrc));
  gl.attachShader(prog, sh(gl.FRAGMENT_SHADER, fsSrc));
  gl.linkProgram(prog);
  gl.useProgram(prog);

  // --- Геометрия
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1, 1,-1,1,1,-1,1]), gl.STATIC_DRAW);
  const locP = gl.getAttribLocation(prog, 'p');
  gl.enableVertexAttribArray(locP);
  gl.vertexAttribPointer(locP, 2, gl.FLOAT, false, 0, 0);

  // --- Uniforms
  const uRes   = gl.getUniformLocation(prog, 'res');
  const uYaw   = gl.getUniformLocation(prog, 'yaw');
  const uPitch = gl.getUniformLocation(prog, 'pitch');
  const uRoll  = gl.getUniformLocation(prog, 'roll');
  const uFov   = gl.getUniformLocation(prog, 'fov');

  // --- Текстура
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  function loadImage(src){ return new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=src; }); }
  function setTexture(img){ gl.bindTexture(gl.TEXTURE_2D, tex); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img); }

  loadImage('panorama_4096x2048.jpg')
    .then(img=>{ setTexture(img); say('Загружено: panorama_4096x2048.jpg'); })
    .catch(()=> say('Выбери файл панорамы.'));

  document.getElementById('picker').addEventListener('change', e=>{
    const f=e.target.files&&e.target.files[0]; if(!f) return;
    loadImage(URL.createObjectURL(f)).then(img=>{ setTexture(img); say('Загружено: '+f.name); });
  });

  // --- Состояние
  let yaw=0,pitch=0,roll=0,fov=Math.PI/3;
  let gyroOn=false, orientHandler=null, prevA=null, yawVel=0;
  const LPF=0.25, HORIZ_SOFT=0.3;
  const gyroBtn=document.getElementById('gyroBtn');
  const centerBtn=document.getElementById('centerBtn');
  const fsBtn=document.getElementById('fsBtn');
  const PITCH_LIMIT=Math.PI/2-0.001;
  const MIN_FOV=Math.PI/9;
  const MAX_FOV=Math.PI/1.1;

  const clamp=(v,min,max)=>v<min?min:v>max?max:v;
  const clampPitch=v=>clamp(v,-PITCH_LIMIT,PITCH_LIMIT);
  const clampFov=v=>clamp(v,MIN_FOV,MAX_FOV);

  // ориентация экрана для корректного roll в портрете/ландшафте
  let scrAng = (screen.orientation && screen.orientation.angle) || window.orientation || 0;
  window.addEventListener('orientationchange', ()=> {
    scrAng = (screen.orientation && screen.orientation.angle) || window.orientation || 0;
  });

  function handleOrient(ev){
    if(!gyroOn) return;
    if(ev.alpha==null || ev.beta==null || ev.gamma==null) return;
    const a=ev.alpha*Math.PI/180;   // yaw
    const b=ev.beta *Math.PI/180;   // pitch-сенсор
    const g=ev.gamma*Math.PI/180;   // roll-сенсор

    // unwrap + сглаживание yaw
    if(prevA===null) prevA=a;
    let d=a-prevA; while(d>Math.PI)d-=2*Math.PI; while(d<-Math.PI)d+=2*Math.PI;
    const aSmooth=prevA+d;
    let da=aSmooth-prevA; prevA=aSmooth;
    const wRaw=Math.abs(Math.cos(b));
    const w=wRaw<=HORIZ_SOFT?0:(wRaw-HORIZ_SOFT)/(1-HORIZ_SOFT);
    da*=w;
    yawVel=yawVel*(1-LPF)+da*LPF;
    yaw+=yawVel;

    // ПОЛНЫЙ НАКЛОН ВПЕРЕД/НАЗАД: возвращаем pitch из β
    pitch = clampPitch(b - Math.PI/2);

    // НАКЛОН ВЛЕВО/ВПРАВО: roll из γ с учётом ориентации экрана
    const ang = ((scrAng%360)+360)%360;
    let r = -g;           // портрет: телефон влево → картинка вправо
    if (ang===90)  r = -b;  // ландшафт-право
    if (ang===180) r =  g;  // перевёрнутый портрет
    if (ang===270) r =  b;  // ландшафт-лево
    roll = r;
  }

  async function enableGyro(auto=false){
    if(gyroOn) return;
    if(typeof DeviceOrientationEvent==='undefined'){
      if(!auto) say('Гироскоп не поддерживается этим браузером.');
      return;
    }
    const needsPermission=typeof DeviceOrientationEvent.requestPermission==='function';
    if(auto && needsPermission) return;
    if(needsPermission){
      try{
        const s=await DeviceOrientationEvent.requestPermission();
        if(s!=='granted'){ say('Разреши доступ к ориентации устройства.'); return; }
      }catch(err){
        say('Нет доступа к ориентации устройства.');
        return;
      }
    }
    prevA=null;
    yawVel=0;
    orientHandler=handleOrient;
    window.addEventListener('deviceorientation',orientHandler,true);
    gyroOn=true;
    gyroBtn.textContent='Гироскоп: вкл';
  }

  function disableGyro(){
    if(orientHandler) window.removeEventListener('deviceorientation',orientHandler,true);
    orientHandler=null; gyroOn=false;
    prevA=null;
    yawVel=0;
    gyroBtn.textContent='Гироскоп: выкл';
  }

  gyroBtn.addEventListener('click',()=> gyroOn ? disableGyro():enableGyro());
  const needsPermission=(typeof DeviceOrientationEvent!=='undefined') && (typeof DeviceOrientationEvent.requestPermission==='function');
  if(!needsPermission) enableGyro(true); // автозапуск без запроса разрешений

  centerBtn.addEventListener('click',()=>{
    yaw=0; pitch=0; roll=0;
    fov=Math.PI/3;
    prevA=null;
    yawVel=0;
  });

  const isFullscreen=()=>!!(document.fullscreenElement||document.webkitFullscreenElement||document.msFullscreenElement);
  function updateFsBtn(){ fsBtn.textContent=isFullscreen()?'Exit FS':'Fullscreen'; }
  updateFsBtn();
  document.addEventListener('fullscreenchange',updateFsBtn);
  document.addEventListener('webkitfullscreenchange',updateFsBtn);
  document.addEventListener('msfullscreenchange',updateFsBtn);
  fsBtn.addEventListener('click',()=>{
    if(!isFullscreen()){
      const el=document.documentElement||document.body;
      if(el.requestFullscreen) el.requestFullscreen();
      else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      else if(el.msRequestFullscreen) el.msRequestFullscreen();
    }else{
      if(document.exitFullscreen) document.exitFullscreen();
      else if(document.webkitExitFullscreen) document.webkitExitFullscreen();
      else if(document.msExitFullscreen) document.msExitFullscreen();
    }
  });

  const pointers=new Map();
  let primaryPointerId=null;
  let pinchStartDist=null;
  let pinchStartFov=null;

  const pointerPos=ev=>({x:ev.clientX,y:ev.clientY});
  const firstTwoPointers=()=>{
    const vals=[];
    for(const v of pointers.values()){ vals.push(v); if(vals.length===2) break; }
    return vals.length===2?vals:null;
  };
  const updateDraggingState=()=>{ if(pointers.size>0) cnv.classList.add('dragging'); else cnv.classList.remove('dragging'); };

  cnv.addEventListener('pointerdown',ev=>{
    if(ev.pointerType==='mouse' && ev.button!==0) return;
    if(cnv.setPointerCapture) try{ cnv.setPointerCapture(ev.pointerId); }catch(_){ }
    pointers.set(ev.pointerId,pointerPos(ev));
    if(primaryPointerId===null) primaryPointerId=ev.pointerId;
    if(pointers.size===2){
      const pair=firstTwoPointers();
      if(pair){
        pinchStartDist=Math.hypot(pair[0].x-pair[1].x,pair[0].y-pair[1].y)||1;
        pinchStartFov=fov;
      }
    }
    updateDraggingState();
    ev.preventDefault();
  });

  cnv.addEventListener('pointermove',ev=>{
    if(!pointers.has(ev.pointerId)) return;
    const prev=pointers.get(ev.pointerId);
    const pos=pointerPos(ev);
    pointers.set(ev.pointerId,pos);

    if(pointers.size===1 && primaryPointerId===ev.pointerId){
      const dx=pos.x-prev.x;
      const dy=pos.y-prev.y;
      yaw-=dx*0.005;
      pitch=clampPitch(pitch-dy*0.005);
    }else if(pointers.size>=2 && pinchStartDist){
      const pair=firstTwoPointers();
      if(pair){
        const dist=Math.hypot(pair[0].x-pair[1].x,pair[0].y-pair[1].y);
        if(dist>0){
          const scale=clamp((pinchStartDist/dist),0.25,4);
          fov=clampFov(pinchStartFov*scale);
        }
      }
    }
    ev.preventDefault();
  });

  function releasePointer(ev){
    if(!pointers.has(ev.pointerId)) return;
    if(cnv.releasePointerCapture) try{ cnv.releasePointerCapture(ev.pointerId); }catch(_){ }
    pointers.delete(ev.pointerId);
    if(primaryPointerId===ev.pointerId){
      const next=pointers.keys().next();
      primaryPointerId=next.done?null:next.value;
    }
    if(pointers.size<2){
      pinchStartDist=null;
      pinchStartFov=null;
    }else{
      const pair=firstTwoPointers();
      if(pair){
        pinchStartDist=Math.hypot(pair[0].x-pair[1].x,pair[0].y-pair[1].y)||1;
        pinchStartFov=fov;
      }
    }
    updateDraggingState();
  }

  cnv.addEventListener('pointerup',releasePointer);
  cnv.addEventListener('pointercancel',releasePointer);
  cnv.addEventListener('lostpointercapture',releasePointer);
  window.addEventListener('blur',()=>{
    pointers.clear();
    primaryPointerId=null;
    pinchStartDist=null;
    pinchStartFov=null;
    updateDraggingState();
  });

  cnv.addEventListener('wheel',ev=>{
    if(ev.ctrlKey) return;
    const scale=Math.exp(ev.deltaY*0.001);
    fov=clampFov(fov*scale);
    ev.preventDefault();
  },{passive:false});
  cnv.addEventListener('contextmenu',ev=>ev.preventDefault());

  // --- Resize + Render
  function resize(){
    const ratio=Math.min(window.devicePixelRatio||1,1.5);
    cnv.width=innerWidth*ratio; cnv.height=innerHeight*ratio;
    gl.viewport(0,0,cnv.width,cnv.height);
    gl.uniform2f(uRes,cnv.width,cnv.height);
  }
  addEventListener('resize',resize); resize();

  function frame(){
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(prog);
    gl.bindTexture(gl.TEXTURE_2D,tex);
    gl.uniform1f(uYaw,yaw);
    gl.uniform1f(uPitch,pitch);
    gl.uniform1f(uRoll,roll);
    gl.uniform1f(uFov,fov);
    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(frame);
  }
  frame();
})();
</script>
</body>
</html>
