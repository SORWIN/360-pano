<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>360 Панорама — офлайн</title>
<link rel="icon" href="data:,">
<style>
  html,body{margin:0;height:100%;background:#000;color:#ddd;font-family:system-ui}
  #ui{position:fixed;left:12px;top:12px;display:flex;gap:8px;z-index:10;flex-wrap:wrap}
  #ui>*{background:#111a;border:1px solid #333;border-radius:10px;padding:6px 10px;font-size:14px}
  #note{position:fixed;left:12px;bottom:12px;background:#111a;border:1px solid #333;border-radius:10px;padding:8px 10px;z-index:10;max-width:min(92vw,860px)}
  canvas{display:block;width:100vw;height:100vh}
  button{cursor:pointer}
</style>
</head>
<body>
<div id="ui">
  <input id="picker" type="file" accept="image/jpeg,image/png,image/webp">
  <button id="gyroBtn">Гироскоп: выкл</button>
  <button id="centerBtn">Центр</button>
  <button id="fsBtn">Fullscreen</button>
</div>
<div id="note">Ищу <code>panorama_4096x2048.jpg</code> рядом с этим файлом… ЛКМ/тач — вращение, колесо/пинч — зум.</div>
<canvas id="gl"></canvas>

<script>
(() => {
  const cnv = document.getElementById('gl');
  const gl = cnv.getContext('webgl', { antialias:false, alpha:false });
  const note = document.getElementById('note');
  const say = s => note.textContent = s;
  if (!gl) { say('WebGL недоступен.'); return; }

  // --- Шейдеры (yaw, pitch, roll)
  const vsSrc = `
    attribute vec2 p;
    varying vec2 v;
    void main(){ v=p; gl_Position=vec4(p,0.0,1.0); }
  `;
  const fsSrc = `
    precision highp float;
    varying vec2 v;
    uniform sampler2D pano;
    uniform vec2 res;
    uniform float yaw;
    uniform float pitch;
    uniform float roll;
    uniform float fov;

    vec3 rayDir(vec2 uv, float fovY){
      float yScale = tan(fovY*0.5);
      float xScale = yScale * (res.x/res.y);
      return normalize(vec3(uv.x*xScale, uv.y*yScale, -1.0));
    }
    mat3 rotX(float a){ float c=cos(a), s=sin(a); return mat3(1.,0.,0., 0.,c,s, 0.,-s,c); }
    mat3 rotY(float a){ float c=cos(a), s=sin(a); return mat3(c,0.,-s, 0.,1.,0., s,0.,c); }
    mat3 rotZ(float a){ float c=cos(a), s=sin(a); return mat3(c,s,0., -s,c,0., 0.,0.,1.); }

    void main(){
      vec3 d = rotZ(roll) * rotY(yaw) * (rotX(pitch) * rayDir(v, fov));
      float lon = atan(d.z, d.x);
      float lat = asin(clamp(d.y, -1.0, 1.0));
      float u = lon/(2.0*3.141592653589793) + 0.5;
      float vv = 0.5 - (lat/3.141592653589793);
      u = fract(u);
      vv = clamp(vv, 0.0, 1.0);
      gl_FragColor = texture2D(pano, vec2(u, vv));
    }
  `;
  function sh(t,src){const s=gl.createShader(t);gl.shaderSource(s,src);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))throw new Error(gl.getShaderInfoLog(s));return s;}
  const prog = gl.createProgram();
  gl.attachShader(prog, sh(gl.VERTEX_SHADER, vsSrc));
  gl.attachShader(prog, sh(gl.FRAGMENT_SHADER, fsSrc));
  gl.linkProgram(prog);
  gl.useProgram(prog);

  // --- Геометрия
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1, 1,-1,1,1,-1,1]), gl.STATIC_DRAW);
  const locP = gl.getAttribLocation(prog, 'p');
  gl.enableVertexAttribArray(locP);
  gl.vertexAttribPointer(locP, 2, gl.FLOAT, false, 0, 0);

  // --- Uniforms
  const uRes   = gl.getUniformLocation(prog, 'res');
  const uYaw   = gl.getUniformLocation(prog, 'yaw');
  const uPitch = gl.getUniformLocation(prog, 'pitch');
  const uRoll  = gl.getUniformLocation(prog, 'roll');
  const uFov   = gl.getUniformLocation(prog, 'fov');
  const uPano  = gl.getUniformLocation(prog, 'pano');
  gl.uniform1i(uPano, 0);

  // --- Текстура
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  function loadImage(src){ return new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=src; }); }
  function setTexture(img){ gl.bindTexture(gl.TEXTURE_2D, tex); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img); }

  loadImage('panorama_4096x2048.jpg')
    .then(img=>{ setTexture(img); say('Загружено: panorama_4096x2048.jpg'); })
    .catch(()=> say('Выбери файл панорамы.'));

  document.getElementById('picker').addEventListener('change', e=>{
    const f=e.target.files&&e.target.files[0]; if(!f) return;
    loadImage(URL.createObjectURL(f)).then(img=>{ setTexture(img); say('Загружено: '+f.name); });
  });

  // --- Состояние
  let yaw=0,pitch=0,roll=0,fov=Math.PI/3;
  let gyroOn=false, prevA=null, yawVel=0;

  // ориентация экрана
  let scrAng = (screen.orientation && screen.orientation.angle) || window.orientation || 0;
  window.addEventListener('orientationchange', ()=> {
    scrAng = (screen.orientation && screen.orientation.angle) || window.orientation || 0;
  });

  // --- Гиро обработчик
  const LPF=0.25;           // сглаживание yaw
  const gyroBtn=document.getElementById('gyroBtn');

  // вспомогательная математика для устойчивого roll
  const ca=Math.cos, sa=Math.sin;
  function Rz(t){ const c=ca(t), s=sa(t); return [[c,-s,0],[s,c,0],[0,0,1]]; }
  function Rx(t){ const c=ca(t), s=sa(t); return [[1,0,0],[0,c,s],[0,-s,c]]; }
  function Ry(t){ const c=ca(t), s=sa(t); return [[c,0,-s],[0,1,0],[s,0,c]]; }
  function mul(A,B){ return [
    [A[0][0]*B[0][0]+A[0][1]*B[1][0]+A[0][2]*B[2][0],
     A[0][0]*B[0][1]+A[0][1]*B[1][1]+A[0][2]*B[2][1],
     A[0][0]*B[0][2]+A[0][1]*B[1][2]+A[0][2]*B[2][2]],
    [A[1][0]*B[0][0]+A[1][1]*B[1][0]+A[1][2]*B[2][0],
     A[1][0]*B[0][1]+A[1][1]*B[1][1]+A[1][2]*B[2][1],
     A[1][0]*B[0][2]+A[1][1]*B[1][2]+A[1][2]*B[2][2]],
    [A[2][0]*B[0][0]+A[2][1]*B[1][0]+A[2][2]*B[2][0],
     A[2][0]*B[0][1]+A[2][1]*B[1][1]+A[2][2]*B[2][1],
     A[2][0]*B[0][2]+A[2][1]*B[1][2]+A[2][2]*B[2][2]],
  ];}
  function tr(A){ return [[A[0][0],A[1][0],A[2][0]],[A[0][1],A[1][1],A[2][1]],[A[0][2],A[1][2],A[2][2]]]; }

  function handleOrient(ev){
    const a=(ev.alpha||0)*Math.PI/180; // yaw-сенсор
    const b=(ev.beta ||0)*Math.PI/180; // pitch-сенсор
    const g=(ev.gamma||0)*Math.PI/180; // roll-сенсор

    // YAW: unwrap + фильтр
    if(prevA===null) prevA=a;
    let da = a - prevA;
    while(da> Math.PI) da -= 2*Math.PI;
    while(da<-Math.PI) da += 2*Math.PI;
    prevA += da;
    yawVel = yawVel*(1-LPF) + da*LPF;
    yaw += yawVel;

    // PITCH: из β с ограничением
    const lim = Math.PI/2 - 0.001;
    pitch = Math.max(-lim, Math.min(lim, b - Math.PI/2));

    // ROLL: устойчивое извлечение из матриц (без перескока на горизонте)
    const ang = (((scrAng%360)+360)%360) * Math.PI/180;
    let R = mul(Rz(a), mul(Rx(b), Ry(g)));  // ориентация устройства (W3C)
    R = mul(Rz(-ang), R);                   // поправка на ориентацию экрана
    const A = mul(Ry(yaw), Rx(pitch));      // наша текущая камера по yaw/pitch
    const M = mul(tr(A), R);                // остаток должен быть чистым Rz(roll)
    const rollRaw = Math.atan2(M[0][1], M[1][1]);

    // можно слегка сгладить roll, но без подавления на горизонте
    // (если хочешь мгновенный отклик — просто: roll = rollRaw;)
    roll = roll*0.75 + rollRaw*0.25;
  }

  // --- Вкл/выкл гиро
  let gyroOn=false, orientHandler=null;
  async function enableGyro(){
    if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
      try{const s=await DeviceMotionEvent.requestPermission(); if(s!=='granted'){say('Разреши доступ к датчикам.');return;}}catch{return;}
    }
    orientHandler=handleOrient;
    window.addEventListener('deviceorientation',orientHandler,true);
    gyroOn=true;
    gyroBtn.textContent='Гироскоп: вкл';
  }
  function disableGyro(){
    if(orientHandler) window.removeEventListener('deviceorientation',orientHandler,true);
    orientHandler=null; gyroOn=false;
    gyroBtn.textContent='Гироскоп: выкл';
  }
  gyroBtn.addEventListener('click',()=> gyroOn ? disableGyro():enableGyro());
  enableGyro(); // автозапуск

  // --- Resize + Render
  function resize(){
    const ratio=Math.min(window.devicePixelRatio||1,1.5);
    cnv.width=innerWidth*ratio; cnv.height=innerHeight*ratio;
    gl.viewport(0,0,cnv.width,cnv.height);
    gl.uniform2f(uRes,cnv.width,cnv.height);
  }
  addEventListener('resize',resize); resize();

  function frame(){
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(prog);
    gl.bindTexture(gl.TEXTURE_2D,tex);
    gl.uniform1f(uYaw,yaw);
    gl.uniform1f(uPitch,pitch);
    gl.uniform1f(uRoll,roll);
    gl.uniform1f(uFov,fov);
    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(frame);
  }
  frame();
})();
</script>
</body>
</html>
